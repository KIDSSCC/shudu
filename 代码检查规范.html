
<!-- saved from url=(0049)file:///C:/Users/lenovo/Documents/QueryResult.htm -->
<html xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Code Query Report</title><style>
          BODY { font-family: Trebuchet MS; font-size: 10pt; }
          TD { font-family: Trebuchet MS; font-size: 10pt; }
          .title { font-size: 25pt; font-weight: bold; }
          .subtitle { color: #883333; font-size: 20pt; font-weight: bold; background-color: #CCCCCC }
          .subtitleref { color: blue; font-size: 10pt }
          .info {color: black; font-size: 10pt}
          .biginfo {color: black; font-size: 12pt ; font-weight: bold}
          .infobold {color: black; font-size: 10pt ; font-weight: bold}
          .hdrcell_left  { color: #FFFFFF ; font-weight: bold; background-color: #B3B3B3; text-align: left;}
          .hdrcell_leftb  { color: #FFFFFF ; font-weight: bold; background-color: #939393; text-align: left;}
          .hdrcell_right { color: #FFFFFF ; font-weight: bold; background-color: #B3B3B3; text-align: right;}
          .hdrcell_rightb { color: #FFFFFF ; font-weight: bold; background-color: #939393; text-align: right;}
          .datacell_left0 { color: #000055; background-color: #DBDBDB; text-align: left; }
          .datacell_leftb0{ color: #000055; background-color: #BBBBBB; text-align: left; }
          .datacell_right0{ color: #000055; background-color: #DBDBDB; text-align: right; }
          .datacell_rightb0{ color: #000055; background-color: #BBBBBB; text-align: right; }
          .datacell_red0 { color: #000055; background-color: #FFBBBB; text-align: right; }
          .datacell_left1 { color: #000055; background-color: #EAEAEA; text-align: left; }
          .datacell_leftb1 { color: #000055; background-color: #CACACA; text-align: left; }
          .datacell_right1{ color: #000055; background-color: #EAEAEA; text-align: right; }
          .datacell_rightb1{ color: #000055; background-color: #CACACA; text-align: right; }
          .datacell_red1 { color: #000055; background-color: #FFCCCC; text-align: right; }
          .datacell_stat0 { color: #000055; background-color: #C0C0FF; text-align: right; }
          .datacell_stat1 { color: #000055; background-color: #D0D0FF; text-align: right; }
          .datacell_empty { color: #000055; background-color: #FFFFFF; text-align: right; }
          .cellreddoc { color: #000000; background-color: #FFCCCC; text-align: left; font-size: 10pt ; font-weight: bold}
          .cql_ok { color: #000000; background-color: #A0FFA0; text-align: left; font-size: 10pt ; font-weight: bold}
          .cql_warning { color: #000000; background-color: #FFFF70; text-align: left; font-size: 10pt ; font-weight: bold}
          .cql_error { color: #FFFFFF; background-color: #FF0000; text-align: left; font-size: 10pt ; font-weight: bold}
        </style></head><body>Pair_Programming  (analysis done Today 16:37 most recent)<br><br><pre style="background: #F6F6F6"><font color="#008000">//&nbsp;&lt;Name&gt;</font><b style="color:#008000;background-color:#DCFFDC">Non-violated&nbsp;rules</b><font color="#008000">&lt;/Name&gt;<br></font><font color="#0000FF">from</font>&nbsp;<font color="#000000">r</font>&nbsp;<font color="#0000FF">in</font>&nbsp;<b style="color:#000064;background-color:#E8E8FF">Rules</b><font color="#000000"><br></font><font color="#0000FF">where</font>&nbsp;<font color="#000000">!</font><font color="#000000">r</font><font color="#000000">.</font><font color="#000000">IsViolated</font><font color="#000000">(</font><font color="#000000">)</font><font color="#000000"><br></font><font color="#0000FF">select</font>&nbsp;<font color="#0000FF">new</font>&nbsp;<font color="#000000">{</font><font color="#000000">&nbsp;<br>&nbsp;&nbsp;&nbsp;</font><font color="#000000">r</font><font color="#000000">,</font><font color="#000000"><br>&nbsp;&nbsp;&nbsp;</font><font color="#000000">Category</font>&nbsp;<font color="#000000">=</font>&nbsp;<font color="#000000">r</font><font color="#000000">.</font><font color="#000000">Category</font><font color="#000000"><br></font><font color="#000000">}</font></pre><table border="1" cellpadding="3" cellspacing="0" bordercolor="white"><tbody><tr><td class="hdrcell_left">266 rules</td><td class="hdrcell_left">Category</td><td class="hdrcell_left">Full Name</td></tr><tr><td class="datacell_left1">Avoid types too big</td><td class="datacell_right1">Project Rules \ Code Smells</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Avoid types with too many methods</td><td class="datacell_right0">Project Rules \ Code Smells</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Avoid types with too many fields</td><td class="datacell_right1">Project Rules \ Code Smells</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Avoid methods too big, too complex</td><td class="datacell_right0">Project Rules \ Code Smells</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Avoid methods with too many parameters</td><td class="datacell_right1">Project Rules \ Code Smells</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Avoid methods with too many local variables</td><td class="datacell_right0">Project Rules \ Code Smells</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Avoid methods with too many overloads</td><td class="datacell_right1">Project Rules \ Code Smells</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Avoid types with poor cohesion</td><td class="datacell_right0">Project Rules \ Code Smells</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">DCL50-CPP: Do not define a C-style variadic function</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Declarations and Initialization</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">DCL51-CPP: Do not declare or define a reserved identifier</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Declarations and Initialization</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">DCL52-CPP:Never qualify a reference type with const or volatile</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Declarations and Initialization</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">DCL53-CPP: Do not write syntactically ambiguous declarations</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Declarations and Initialization</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">DCL54-CPP: Overload allocation and deallocation functions as a pair in the same scope</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Declarations and Initialization</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">DCL57-CPP: Do not let exceptions escape from destructors or deallocation functions</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Declarations and Initialization</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">DCL58-CPP: Do not modify the standard namespaces</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Declarations and Initialization</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">DCL59-CPP: Do not define an unnamed namespace in a header file</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Declarations and Initialization</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">EXP50-CPP: Do not depend on the order of evaluation for side effects</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">EXP52-CPP: Do not rely on side effects in unevaluated operands</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">EXP53-CPP: Do not read uninitialized memory</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">EXP54-CPP: Do not access an object outside of its lifetime</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">EXP55-CPP: Do not access a cv-qualified object through a cvunqualified type</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">EXP57-CPP: Do not cast or delete pointers to incomplete classes</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">EXP58-CPP: Pass an object of the correct type to va_start</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">EXP61-CPP: A lambda object must not outlive any of its reference captured objects</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">EXP62-CPP: Do not access the bits of an object representation that are not part of the objectâ€™s value representation</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Expressions(Exp)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">MEM50-CPP:Do not access freed memory</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Memory Management (MEM)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">MEM51-CPP:Properly deallocate dynamically allocated resources</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Memory Management (MEM)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">MEM53-CPP. Explicitly construct and destruct objects when manually managing object lifetime</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Memory Management (MEM)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">MEM56-CPP:Do not store an already-owned pointer value in an unrelated smart pointer</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Memory Management (MEM)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">MEM57-CPP. Avoid using default operator new for over-aligned types</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Memory Management (MEM)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">ERR51-CPP: Handle all exceptions</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Exceptions and Error Handling (ERR)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">ERR52-CPP: Do not use setjmp() or longjmp()</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Exceptions and Error Handling (ERR)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">ERR53-CPP: Do not reference base classes or class data members in a constructor or destructor function-try-block handler</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Exceptions and Error Handling (ERR)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">ERR54-CPP: Catch handlers should order their parameter types from most derived to least derived</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Exceptions and Error Handling (ERR)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">ERR58-CPP. Handle all exceptions thrown before main() begins executing</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Exceptions and Error Handling (ERR)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">ERR60-CPP: Exception objects must be nothrow copynconstructible</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Exceptions and Error Handling (ERR)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">ERR61-CPP: Catch exceptions by lvalue reference</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Exceptions and Error Handling (ERR)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">OOP50-CPP: Do not invoke virtual functions from constructors or destructors</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Object Oriented Programming (OOP)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">OOP52-CPP: Do not delete a polymorphic object without a virtual destructor</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Object Oriented Programming (OOP)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">OOP53-CPP: Write constructor member initializers in the canonical order</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Object Oriented Programming (OOP)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">OOP54-CPP: Gracefully handle self-copy assignment</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Object Oriented Programming (OOP)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">OOP57-CPP. Prefer special member functions and overloaded operators to C Standard Library functions</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Object Oriented Programming (OOP)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">OOP58-CPP: Copy operations must not mutate the source object</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Object Oriented Programming (OOP)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">MSC50-CPP: Do not use std::rand() for generating pseudorandom numbers</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Miscellaneous (MSC)</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">MSC51-CPP. Ensure your random number generator is properlyseeded</td><td class="datacell_right1">Project Rules \ Coding Standards \ Cert C++ \ Miscellaneous (MSC)</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">CTR50-CPP: Guarantee that container indices and iterators are within the valid range</td><td class="datacell_right0">Project Rules \ Coding Standards \ Cert C++ \ Containers</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Divide By Zero</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Unchecked Error Condition</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Declaration of Catch for Generic Exception</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Improper Release of Memory Before Removing Last Reference ('Memory Leak')</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Double Free</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Use of Uninitialized Variable</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Incomplete Cleanup</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">NULL Pointer Dereferenced</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Use of Obsolete Functions</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Comparing instead of Assigning</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Omitted Break Statement in Switch</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Dead Code</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Assignment to Variable without Use ('Unused Variable')</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Expression is Always False</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Expression is Always True</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Function Call with Incorrectly Specified Arguments</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Use of Potentially Dangerous Function</td><td class="datacell_right0">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Operator Precedence Logic Error</td><td class="datacell_right1">Project Rules \ Coding Standards \ CWE Coding Standard</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Base class should not use derivatives</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Class shouldn't be too deep in inheritance tree</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Constructor should not call a virtual methods</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Don't assign static fields from instance methods</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Avoid Abstract Classes with too many methods</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Type should not have too many responsibilities</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Nested types should not be visible</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Projects with poor cohesion (RelationalCohesion)</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Projects that don't satisfy the Abstractness/Instability principle</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Constructors of abstract classes should be declared as protected or private</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">The class does not have a constructor.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Class has a constructor with 1 argument that is not explicit.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Value of pointer var, which points to allocated memory, is copied in copy constructor instead of allocating new memory.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">class class does not have a copy constructor which is recommended since the class contains a pointer to allocated memory.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Member variable  is not initialized in the constructor.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Member variable  is not assigned a value in classname::operator=.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Unused private function: classname::funcname</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Using memfunc on class that contains a classname.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Using memfunc on class that contains a reference.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Using memset() on class which contains a floating point number.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Memory for class instance allocated with malloc(), but class provides constructors.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Memory for class instance allocated with malloc(), but class contains a std::string.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">class::operator= should return class &amp;.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Class Base which is inherited by class Derived does not have a virtual destructor.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Suspicious pointer subtraction. Did you intend to write -&gt;?</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">operator= should return reference to this instance.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">No return statement in non-void function causes undefined behavior.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">operator= should either return reference to this instance or be declared private and left unimplemented.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">operator= should check for assignment to self to avoid problems with dynamic memory.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Variable  is assigned in constructor body. Consider performing initialization in initialization list.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Member variable  is initialized by itself.</td><td class="datacell_right0">Project Rules \ Object Oriented Design</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">The class class defines member variable with name variable also defined in its parent class class.</td><td class="datacell_right1">Project Rules \ Object Oriented Design</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Returning/dereferencing p after it is deallocated / released</td><td class="datacell_right0">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Memory pointed to by varname is freed twice.</td><td class="datacell_right1">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Allocation with funcName, funcName doesnt release it.</td><td class="datacell_right0">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Return value of allocation function funcName is not stored.</td><td class="datacell_right1">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Possible leak in public function. The pointer varname is not deallocated before it is allocated.</td><td class="datacell_right0">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Class class is unsafe, class::varname can leak by wrong usage.</td><td class="datacell_right1">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Memory leak: varname</td><td class="datacell_right0">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Resource leak: varname</td><td class="datacell_right1">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Deallocating a deallocated pointer: varname</td><td class="datacell_right0">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Dereferencing varname after it is deallocated / released</td><td class="datacell_right1">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">The allocated size sz is not a multiple of the underlying types size.</td><td class="datacell_right0">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Mismatching allocation and deallocation: varname</td><td class="datacell_right1">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Common realloc mistake: varname nulled but not freed upon failure</td><td class="datacell_right0">Project Rules \ Memory Management \ Leaks</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Null pointer dereference</td><td class="datacell_right1">Project Rules \ Memory Management \ Null Pointer</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Possible null pointer dereference if the default parameter value is used: pointer</td><td class="datacell_right0">Project Rules \ Memory Management \ Null Pointer</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Either the condition is redundant or there is possible null pointer dereference: pointer.</td><td class="datacell_right1">Project Rules \ Memory Management \ Null Pointer</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Address of local auto-variable assigned to a function parameter.</td><td class="datacell_right0">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Address of an auto-variable returned.</td><td class="datacell_right1">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Pointer to local array variable returned.</td><td class="datacell_right0">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Reference to auto variable returned.</td><td class="datacell_right1">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Reference to temporary returned.</td><td class="datacell_right0">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Deallocation of an auto-variable results in undefined behaviour.</td><td class="datacell_right1">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Address of function parameter parameter returned.</td><td class="datacell_right0">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Assignment of function parameter has no effect outside the function.</td><td class="datacell_right1">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?</td><td class="datacell_right0">Project Rules \ Memory Management \ Auto Variables</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Array array[2] index array[1][1] out of bounds.</td><td class="datacell_right1">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Buffer is accessed out of bounds: buffer</td><td class="datacell_right0">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append.</td><td class="datacell_right1">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">index is out of bounds: Supplied size 2 is larger than actual size 1.</td><td class="datacell_right0">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">The size argument is given as a char constant.</td><td class="datacell_right1">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Array index -1 is out of bounds.</td><td class="datacell_right0">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Buffer overrun possible for long command line arguments.</td><td class="datacell_right1">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Undefined behaviour, pointer arithmetic  is out of bounds.</td><td class="datacell_right0">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Array index index is used before limits check.</td><td class="datacell_right1">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination).</td><td class="datacell_right0">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">The array array is too small, the function function expects a bigger one.</td><td class="datacell_right1">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Memory allocation size is negative.</td><td class="datacell_right0">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Declaration of array  with negative size is undefined behaviour</td><td class="datacell_right1">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Array x[10] accessed at index 20, which is out of bounds. Otherwise condition y==20 is redundant.</td><td class="datacell_right0">Project Rules \ Memory Management \ Bounds Checking</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Invalid iterator: iterator</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Same iterator is used with different containers container1 and container2.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Iterators of different containers are used together.</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Invalid iterator iter used.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">When i==foo.size(), foo[i] is out of bounds.</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">After push_back|push_front|insert(), the iterator iterator may be invalid.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Invalid pointer pointer after push_back().</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Dangerous comparison using operator&lt; on iterator.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Suspicious condition. The result of find() is an iterator, but it is not properly checked.</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Inefficient usage of string::find() in condition; string::compare() would be faster.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Dangerous usage of c_str(). The value returned by c_str() is invalid after this call.</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Returning the result of c_str() in a function that returns std::string is slow and redundant.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Passing the result of c_str() to a function that takes std::string as argument no. 0 is slow and redundant.</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Possible inefficient checking for list emptiness.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Missing bounds check for extra iterator increment in loop.</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Redundant checking of STL container element existence before removing it.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">You can randomly lose access to pointers if you store auto_ptr pointers in an STL container.</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Object pointed by an auto_ptr is destroyed using operator delete. You should not use auto_ptr for pointers obtained with operator new[].</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Object pointed by an auto_ptr is destroyed using operator delete. You should not use auto_ptr for pointers obtained with function malloc.</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">It is inefficient to call str.find(str) as it always returns 0.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">It is inefficient to swap a object with itself by calling str.swap(str)</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Ineffective call of function substr because it returns a copy of the object. Use operator= instead.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Ineffective call of function empty(). Did you intend to call clear() instead?</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Return value of std::remove() ignored. Elements remain in container.</td><td class="datacell_right0">Project Rules \ STL</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Possible dereference of an invalid iterator: i</td><td class="datacell_right1">Project Rules \ STL</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Boolean value assigned to pointer.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ Boolean</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Boolean value assigned to floating point variable.</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ Boolean</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Comparison of a function returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ Boolean</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Comparison of two functions returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator.</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ Boolean</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Comparison of a variable having boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ Boolean</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Incrementing a variable of type bool with postfix operator++ is deprecated by the C++ Standard. You should assign it the value true instead.</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ Boolean</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Comparison of a boolean expression with an integer other than 0 or 1.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ Boolean</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Converting pointer arithmetic result to bool. The bool is always true unless there is undefined behaviour.</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ Boolean</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Modifying string literal directly or indirectly is undefined behaviour.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Undefined behavior: Variable varname is used as parameter and destination in s[n]printf().</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Unusual pointer arithmetic. A value of type char is added to a string literal.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">String literal Hello World doesnt match length argument for substr().</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">String literal compared with variable foo. Did you intend to use strcmp() instead?</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Char literal compared with pointer foo. Did you intend to dereference it?</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Conversion of string literal Hello World to bool always evaluates to true.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Unnecessary comparison of static strings.</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Comparison of identical string variables.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ String</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Shifting 32-bit value by 64 bits is undefined behaviour</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ Type</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Signed integer overflow for expression .</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ Type</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Suspicious code: sign conversion of var in calculation, even though var can have a negative value</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ Type</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information.</td><td class="datacell_right0">Project Rules \ Primitive Types Usage \ Type</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information.</td><td class="datacell_right1">Project Rules \ Primitive Types Usage \ Type</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">scanf is deprecated: This function or variable may be unsafe. Consider using scanf_s instead.</td><td class="datacell_right0">Project Rules \ IO usage</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Invalid usage of output stream: &lt;&lt; std::cout.</td><td class="datacell_right1">Project Rules \ IO usage</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">fflush() called on input stream stdin may result in undefined behaviour on non-linux systems.</td><td class="datacell_right0">Project Rules \ IO usage</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour.</td><td class="datacell_right1">Project Rules \ IO usage</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Read operation on a file that was opened only for writing.</td><td class="datacell_right0">Project Rules \ IO usage</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Write operation on a file that was opened only for reading.</td><td class="datacell_right1">Project Rules \ IO usage</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Used file that is not opened.</td><td class="datacell_right0">Project Rules \ IO usage</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Repositioning operation performed on a file opened in append mode has no effect.</td><td class="datacell_right1">Project Rules \ IO usage</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">scanf() without field width limits can crash with huge input data.</td><td class="datacell_right0">Project Rules \ IO usage</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">printf format string requires 3 parameters but only 2 are given.</td><td class="datacell_right1">Project Rules \ IO usage</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">I in format string (no. 1) is a length modifier and cannot be used without a conversion specifier.</td><td class="datacell_right0">Project Rules \ IO usage</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Width 5 given in format string (no. 10) is larger than destination buffer [0], use %-1s to prevent overflowing it.</td><td class="datacell_right1">Project Rules \ IO usage</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">printf: referencing parameter 2 while 1 arguments given</td><td class="datacell_right0">Project Rules \ IO usage</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Assigning a pointer to an integer is not portable.</td><td class="datacell_right1">Project Rules \ 64-bit portability</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Assigning an integer to a pointer is not portable.</td><td class="datacell_right0">Project Rules \ 64-bit portability</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Returning an integer in a function with pointer return type is not portable.</td><td class="datacell_right1">Project Rules \ 64-bit portability</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Returning an address value in a function with integer return type is not portable.</td><td class="datacell_right0">Project Rules \ 64-bit portability</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Either the condition is redundant or there is division by zero at line 0.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Instance of varname object is destroyed immediately.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Casting between float* and double* which have an incompatible binary data representation.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Shifting a negative value is undefined behaviour</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Buffer varname must have size of 2 integers if used as parameter of pipe().</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Buffer var is being written before its old content has been used.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Variable var is reassigned a value before the old one has been used.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Comparison of two identical variables with isless(varName,varName) always evaluates to false.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Storing func_name() return value in char variable and then comparing with EOF.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Function parameter parametername should be passed by reference.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Redundant code: Found a statement that begins with type constant.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Signed char type used as array index.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">char type used as array index.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">When using char variables in bit operations, sign extension can generate unexpected results.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">The scope of the variable varname can be reduced.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Variable var is reassigned a value before the old one has been used. break; missing?</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Buffer var is being written before its old content has been used. break; missing?</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Redundant assignment of varname to itself.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">memset() called to fill 0 bytes.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">The 2nd memset() argument varname is a float, its representation is implementation defined.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">The 2nd memset() argument varname doesnt fit into an unsigned char.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Clarify calculation precedence for + and ?.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Ineffective statement similar to *A++;. Did you intend to write (*A)++;?</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Same expression on both sides of &amp;&amp;.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Same expression in both branches of ternary operator.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Consecutive return, break, continue, goto or throw statements are unnecessary.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Statements following return, break, continue, goto or throw will never be executed.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Checking if unsigned variable varname is less than zero.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Unsigned variable varname cant be negative so it is unnecessary to test it.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">A pointer can not be negative so it is either pointless or an error to check if it is.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">A pointer can not be negative so it is either pointless or an error to check if it is not.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Using NaN/Inf in a computation.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Comma is used in return statement. The comma can easily be misread as a ;.</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Redundant pointer operation on varname - its already a pointer.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Label  is not used. Should this be a case of the enclosing switch()?</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Label  is not used.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Expression x = x++; depends on order of evaluation of side effects</td><td class="datacell_right1">Project Rules \ Misc</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Prefer prefix ++/-- operators for non-primitive types.</td><td class="datacell_right0">Project Rules \ Misc</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Source files should not use the '\r' (CR) character</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">File names should be well-formed</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">No trailing whitespace</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Don't use tab characters</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">No leading and no trailing empty lines</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Line cannot be too long</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">There should not be too many consecutive empty lines</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Source file should not be too long</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">One-line comments should not have forced continuation</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Reserved names should not be used for preprocessor macros</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Some keywords should be followed by a single space</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Some keywords should be immediately followed by a colon</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Keywords break and continue should be immediately followed by a semicolon</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Keywords return and throw should be immediately followed by a semicolon or a single space</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Semicolons should not be isolated by spaces or comments from the rest of the code</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Keywords catch, for, if, switch and while should be followed by a single space</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Comma should not be preceded by whitespace, but should be followed by one</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Identifiers should not be composed of 'l' and 'O' characters only</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Curly brackets from the same pair should be either in the same line or in the same column</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Negation operator should not be used in its short form</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Source files should contain the copyright notice</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">HTML links in comments and string literals should be correct</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Calls to min/max should be protected against accidental macro substitution</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Calls Unnamed namespaces are not allowed in header files</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_left1">Using namespace is not allowed in header files</td><td class="datacell_right1">Project Rules \ Vera++ Rules</td><td class="datacell_left1">Rule</td></tr><tr><td class="datacell_left0">Control structures should have complete curly-braced block of code</td><td class="datacell_right0">Project Rules \ Vera++ Rules</td><td class="datacell_left0">Rule</td></tr><tr><td class="datacell_stat1">Sum:</td><td class="datacell_stat1">-</td><td class="datacell_empty"></td></tr><tr><td class="datacell_stat0">Average:</td><td class="datacell_stat0">-</td><td class="datacell_empty"></td></tr><tr><td class="datacell_stat1">Minimum:</td><td class="datacell_stat1">-</td><td class="datacell_empty"></td></tr><tr><td class="datacell_stat0">Maximum:</td><td class="datacell_stat0">-</td><td class="datacell_empty"></td></tr><tr><td class="datacell_stat1">Standard deviation:</td><td class="datacell_stat1">-</td><td class="datacell_empty"></td></tr><tr><td class="datacell_stat0">Variance:</td><td class="datacell_stat0">-</td><td class="datacell_empty"></td></tr></tbody></table></body></html>